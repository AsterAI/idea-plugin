{
    parserClass="com.zephir.parser.ZephirParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Zephir"
    psiImplClassSuffix="Impl"
    psiPackage="com.zephir.psi"
    psiImplPackage="com.zephir.psi.impl"

    elementTypeHolderClass="com.zephir.psi.ZephirTypes"
    elementTypeClass="com.zephir.psi.ZephirElementType"
    tokenTypeClass="com.zephir.psi.ZephirTokenType"
    tokens = [
        // regex
        comment='regexp://.*'
        comment_block='regexp:(/*([^*]+|[*]+[^/*])*[*]**/)'
        identifier='regexp:([\\_\$]?[_a-zA-Z\\][a-zA-Z0-9\_\\]*)'
        integer='regexp:([\-]?[0-9]+)|([\-]?[0][x][0-9A-Fa-f]+)'
        double='regexp:([\-]?[0-9]+[\.][0-9]+)'
        schar="regexp:(['] ([\\][']|[\\].|[\001-\377]\[\\'])* ['])"
        string='regexp:(["] ([\\]["]|[\\].|[\001-\377]\[\\"])* ["])'
        cblock='regexp:(%{([^}]+|[}]+[^%{])*}%)'

        // OOP keywords
        NAMESPACE="namespace"
        USE="use"
        AS="as"
        INTEFACE="interface"
        CLASS="class"
        FUNCTION="function" // fn
        EXTENDS="extends"
        IMPLEMENTS="implements"
        ABSTRACT="abstract"
        FINAL="final"
        PUBLIC="public"
        PROTECTED="protected"
        PRIVATE="private"
        STATIC="static"
        INLINE="inline"
        DEPRECATED="deprecated"

        // types
        TYPE_VAR="var"
        TYPE_VOID="void"
        TYPE_INT="int"
        TYPE_UINT="uint"
        TYPE_LONG="long"
        TYPE_ULONG="ulong"
        TYPE_CHAR="char"
        TYPE_UCHAR="uchar"
        TYPE_DOUBLE="double" // float
        TYPE_BOOL="bool" // boolean
        TYPE_STRING="string"
        TYPE_ARRAY="array"
        TYPE_OBJECT="object"
        TYPE_CALLABLE="callable"
        TYPE_RESOURCE="resource"

        // value keywords
        NULL="null"
        FALSE="false"
        TRUE="true"

        // keywords
        LET="let"
        ECHO="echo"
        CONST="const"
        IF="if"
        ELSE="else"
        ELSEIF="elseif"
        SWITCH="swith"
        CASE="case"
        DEFAULT="default"
        DO="do"
        WHILE="while"
        FOR="for"
        LOOP="loop"
        REVERSE="reverse"
        BREAK="break"
        CONTINUE="continue"
        IN="in"
        NEW="new"
        RETURN="return"
        REQUIRE="require"
        CLONE="clone"
        EMPTY="empty"
        TYPEOF="typeof"
        INSTANCEOF="instanceof"
        LIKELY="likely"
        UNLIKELY="unlikely"
        ISSET="isset"
        UNSET="unset"
        THROW="throw"
        FETCH="fetch"
        TRY="try"
        CATCH="catch"

        //other
        PARENTHESES_OPEN="("
        PARENTHESES_CLOSE=")"
        BRACKET_OPEN="{"
        BRACKET_CLOSE="}"
        SBRACKET_OPEN="["
        SBRACKET_CLOSE="]"
        AT="@"
        NOT="!"
        AND="&&"
        OR="||"
        BITWISE_AND="&"
        BITWISE_OR="|"
        BITWISE_XOR="^"
        BITWISE_SHIFTLEFT="<<"
        BITWISE_SHIFTRIGHT=">>"
        ASSIGN="="
        ADDASSIGN="+="
        SUBASSIGN="-="
        MULASSIGN="*="
        EXPASSIGN="**="
        DIVASSIGN="/="
        MODASSIGN="%="
        CONCATASSIGN=".="
        EQUALS="=="
        NOTEQUALS="!="
        IDENTICAL="==="
        NOTIDENTICAL="!=="
        LESSEQUAL="<="
        GREATEREQUAL=">="
        LESS="<"
        GREATER=">"
        ARROW="->"
        DOUBLECOLON="::"
        DOT="."
        ADD="+"
        SUB="-"
        MUL="*"
        EXP="**"
        DIV="/"
        MOD="%"
        INCR="++"
        DECR="--"
        COLON=":"
        DOTCOMMA=";"
        COMMA=","
        QUESTION="?"
    ]

    extends(".*expr")=expr
}

zephir_file ::= top_statement_list

class_modifier ::= 'abstract' | 'final'
visibility ::= 'public' | 'protected' | 'private'

type ::= 'var' | number_type | string_type | bool_type | 'array' | 'object' | 'callable' | 'resource' | class_type
private string_type ::= 'string' | 'char' | 'uchar'
private bool_type ::= 'bool' | 'boolean'
private number_type ::= int_type | double_type | 'uint' | 'long' | 'ulong'
private int_type ::= 'int' | 'integer'
private double_type ::= 'dobule' | 'float'
private class_type ::= '<' identifier '>'

assignment_operator ::= '=' | '+=' | '-=' | '*=' | '**=' | '/=' | '%=' | '.='
math_operator ::= '+' | '-' | '*' | '**' | '/' | '%' | '.'
bool_operator ::= '&&' | '||' | '>' | '<' | '==' | '>=' | '<=' | '==='
bit_operator ::= '&' | '|' | '^' | '>>' | '<<'
increment_operator ::= '++' | '--'

//expr ::= assign_expr | math_expr | bool_expr | bit_expr | parentheses_expr | increment_expr | simple_expr
//assign_expr ::= expr assignment_operator expr
//math_expr ::= expr math_operator expr
//bool_expr ::= expr bool_operator expr
//bit_expr ::= expr bit_operator expr
//parentheses_expr ::= '(' expr ')'
//increment_expr ::= identifier increment_operator



top_statement_list ::= top_statement top_statement_list*
top_statement ::= namespace_definition namespace_uses* namespace_body*

namespace_definition ::= 'namespace' identifier ';' {pin=1}

namespace_uses ::= namespace_use_definition namespace_uses* {pin=2}
namespace_use_definition ::= 'use' identifier namespace_use_alias* ';'
namespace_use_alias ::= 'as' identifier

private namespace_body ::= class_definition | interface_definition {pin=3}

interface_definition ::= 'interface' identifier interface_extending* interface_body
interface_extending ::= 'extends' implement_list

private interface_body ::= '{' interface_methods* constant_list* '}'
interface_methods ::= interface_method interface_methods*
interface_method ::= visibility FUNCTION identifier '(' arguments* ')' return_type* ';'

constant_list ::= constant_definition (constant_list)*
constant_definition ::= 'const' identifier default_value ';'

class_definition ::= class_modifier* 'class' identifier class_extending* class_implementing* class_body
class_body ::= '{' constant_list* properties_list* class_methods* '}'

private class_extending ::= 'extends' identifier
private class_implementing ::= 'implements' implement_list

properties_list ::= property properties_list*
property ::= visibility identifier default_value* ';'

class_methods ::= class_method class_methods*
class_method ::= visibility FUNCTION identifier '(' arguments* ')' return_type* '{' code* '}'

return_type ::= '->' type ('|' return_type)*

arguments ::= argument (',' arguments)*
argument ::= type* identifier default_value*

default_value ::= '=' simple_expr

implement_list ::= implement_identifier (',' implement_list)*
implement_identifier ::= identifier

code ::= statement code*
statement ::= let_statement

let_statement ::= 'let' let_expression ';'
private let_expression ::= expr (',' let_expression)*

expr ::= assign_expr
assign_expr ::= variable_expr assignment_operator simple_expr
simple_expr ::= variable_expr | string | schar | integer | double | array_expr
variable_expr ::= identifier property_access* property_array_access_parts*

property_access ::= property_access_type identifier
property_access_type ::= '->' | '::'

private property_array_access_parts ::= property_array_access_part property_array_access_parts* property_array_access_empty*
private property_array_access_part ::= '[' (variable_expr | string | integer | double) ']'
private property_array_access_empty ::= '[' ']'

array_expr ::= '[' array_body* ']'
private array_body ::= array_item (',' array_body)*
array_item ::= array_item_key_value | simple_expr
private array_item_key_value ::= array_key_expr ':' simple_expr
private array_key_expr ::= variable_expr | string
